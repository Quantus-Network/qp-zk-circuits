use std::collections::BTreeMap;

use anyhow::{bail, Context};
use plonky2::field::types::PrimeField64;
use plonky2::plonk::circuit_data::{CircuitConfig, VerifierCircuitData};
use plonky2::plonk::proof::ProofWithPublicInputs;
use qp_wormhole_inputs::{
    AggregatedPublicCircuitInputs, BlockData, PublicCircuitInputs, PublicInputsByAccount,
};
use wormhole_circuit::circuit::circuit_logic::WormholeCircuit;
use wormhole_circuit::inputs::ParsePublicInputs;
use wormhole_prover::fill_witness;
use zk_circuits_common::{
    circuit::{C, D, F},
    utils::BytesDigest,
};

use zk_circuits_common::aggregation::{
    shuffle_proofs_preserving_first_real, AggregatedProof, AggregationConfig,
};

use crate::build_dummy_circuit_inputs;
use crate::{
    circuits::tree::{aggregate_proofs, WormholeAggregationWrapper},
    dummy_proof::load_dummy_proof,
};

/// A circuit that aggregates proofs from the Wormhole circuit.
pub struct WormholeProofAggregator {
    pub leaf_circuit_data: VerifierCircuitData<F, C, D>,
    pub config: AggregationConfig,
    pub proofs_buffer: Option<Vec<ProofWithPublicInputs<F, C, D>>>,
    /// A single dummy proof template compatible with this aggregator's circuit.
    /// Cloned as many times as needed for padding during `aggregate()`.
    /// Each clone gets a unique nullifier to avoid duplicate nullifier errors on-chain.
    dummy_proof_template: ProofWithPublicInputs<F, C, D>,
}

impl WormholeProofAggregator {
    /// Creates a new [`WormholeProofAggregator`] with a given [`VerifierCircuitData`],
    /// a dummy proof template, and aggregation config.
    ///
    /// The dummy proof must be compatible with the verifier data (generated from the same circuit).
    /// It will be cloned as needed for padding during aggregation.
    pub fn new(
        verifier_circuit_data: VerifierCircuitData<F, C, D>,
        dummy_proof_template: ProofWithPublicInputs<F, C, D>,
        config: AggregationConfig,
    ) -> Self {
        let proofs_buffer = Some(Vec::with_capacity(config.num_leaf_proofs));

        Self {
            leaf_circuit_data: verifier_circuit_data,
            config,
            proofs_buffer,
            dummy_proof_template,
        }
    }

    /// Creates a new [`WormholeProofAggregator`] from a directory containing pre-built circuit files.
    ///
    /// Expects the directory to contain: common.bin, verifier.bin, dummy_proof.bin
    /// (all generated by the circuit builder in a single run).
    pub fn from_prebuilt_dir(
        bins_dir: &std::path::Path,
        config: AggregationConfig,
    ) -> anyhow::Result<Self> {
        let verifier_data = Self::load_verifier_data_from_paths(
            &bins_dir.join("common.bin"),
            &bins_dir.join("verifier.bin"),
        )?;

        let dummy_proof_path = bins_dir.join("dummy_proof.bin");
        let dummy_bytes = std::fs::read(&dummy_proof_path).map_err(|e| {
            anyhow::anyhow!(
                "Failed to read {:?}: {}. \
                 Run 'quantus developer build-circuits' to generate all required binaries.",
                dummy_proof_path,
                e
            )
        })?;
        let dummy_proof_template = load_dummy_proof(dummy_bytes, &verifier_data.common)?;

        Ok(Self::new(verifier_data, dummy_proof_template, config))
    }

    /// Load verifier circuit data from pre-built files.
    fn load_verifier_data_from_paths(
        common_path: &std::path::Path,
        verifier_path: &std::path::Path,
    ) -> anyhow::Result<VerifierCircuitData<F, C, D>> {
        use plonky2::plonk::circuit_data::{CommonCircuitData, VerifierOnlyCircuitData};
        use plonky2::util::serialization::DefaultGateSerializer;
        use std::fs;

        let gate_serializer = DefaultGateSerializer;

        // Load common data
        let common_bytes = fs::read(common_path)
            .map_err(|e| anyhow::anyhow!("Failed to read {:?}: {}", common_path, e))?;
        let common = CommonCircuitData::from_bytes(common_bytes, &gate_serializer)
            .map_err(|e| anyhow::anyhow!("Failed to deserialize common data: {}", e))?;

        // Load verifier-only data
        let verifier_only_bytes = fs::read(verifier_path)
            .map_err(|e| anyhow::anyhow!("Failed to read {:?}: {}", verifier_path, e))?;
        let verifier_only = VerifierOnlyCircuitData::<C, D>::from_bytes(verifier_only_bytes)
            .map_err(|e| anyhow::anyhow!("Failed to deserialize verifier data: {}", e))?;

        Ok(VerifierCircuitData {
            verifier_only,
            common,
        })
    }

    /// Creates a new [`WormholeProofAggregator`] with a given [`CircuitConfig`]
    /// by building the circuit, extracting verifier data, and generating a compatible dummy proof.
    pub fn from_circuit_config(
        circuit_config: CircuitConfig,
        aggregation_config: AggregationConfig,
    ) -> Self {
        use plonky2::iop::witness::PartialWitness;

        // Build the circuit once to get both prover and verifier data from the SAME build.
        // This is critical - using separate builds causes wire assignment mismatches.
        let circuit = WormholeCircuit::new(circuit_config.clone());
        let targets = circuit.targets();
        let circuit_data = circuit.build_circuit();

        // Extract verifier data from this circuit
        let verifier_data = circuit_data.verifier_data();

        // Generate a single dummy proof template (cloned as needed during aggregation)
        let dummy_inputs =
            build_dummy_circuit_inputs().expect("failed to build dummy circuit inputs");
        let mut pw = PartialWitness::new();
        fill_witness(&mut pw, &dummy_inputs, &targets).expect("failed to fill witness");
        let dummy_proof_template = circuit_data
            .prove(pw)
            .expect("failed to generate dummy proof");

        Self::new(verifier_data, dummy_proof_template, aggregation_config)
    }

    pub fn push_proof(&mut self, proof: ProofWithPublicInputs<F, C, D>) -> anyhow::Result<()> {
        if let Some(proofs_buffer) = self.proofs_buffer.as_mut() {
            if proofs_buffer.len() >= self.config.num_leaf_proofs {
                bail!("tried to add proof when proof buffer is full")
            }
            proofs_buffer.push(proof);
        } else {
            self.proofs_buffer = Some(vec![proof]);
        }

        Ok(())
    }

    /// Extract and aggregate leaf public inputs from the filled proof buffer OUTSIDE the circuit.
    /// Groups by `blocks`, then `exit_account`, sums `output_amount`, and collects `nullifiers`.
    /// Used for sanity checks to ensure it matches the public inputs results from the aggregation circuit.
    pub fn parse_aggregated_public_inputs_from_proof_buffer(
        &self,
    ) -> anyhow::Result<AggregatedPublicCircuitInputs> {
        let num_leaves = self.config.num_leaf_proofs;
        let proofs = &self.proofs_buffer;
        let Some(proofs) = proofs else {
            bail!("there are no proofs to aggregate")
        };
        if num_leaves != proofs.len() {
            bail!(
                "proof buffer length {} does not match expected num_leaves {}",
                proofs.len(),
                num_leaves
            )
        };
        let mut leaves: Vec<PublicCircuitInputs> = Vec::new();
        for proof in proofs {
            let pi = PublicCircuitInputs::try_from_proof(proof)?;
            leaves.push(pi);
        }
        aggregate_public_inputs(leaves)
    }

    /// Aggregates `N` number of leaf proofs into an [`AggregatedProof`].
    ///
    /// # Note
    /// Pre-generated dummy proofs use `asset_id = 0` (native token). All real proofs
    /// must also use `asset_id = 0` for the aggregation to succeed, since the circuit
    /// enforces all proofs have the same asset_id.
    pub fn aggregate(&mut self) -> anyhow::Result<AggregatedProof> {
        let Some(mut proofs) = self.proofs_buffer.take() else {
            bail!("there are no proofs to aggregate")
        };

        // Pad with dummy proofs if needed
        let num_dummies_needed = self.config.num_leaf_proofs.saturating_sub(proofs.len());
        if num_dummies_needed > 0 {
            // Verify asset_id matches dummy proofs (asset_id = 0)
            // We cannot modify public inputs post-proof as that invalidates the proof.
            if let Some(first_proof) = proofs.first() {
                let real_asset_id: u32 = first_proof.public_inputs[0]
                    .to_canonical_u64()
                    .try_into()
                    .context("asset_id in first proof exceeds u32 range")?;
                if real_asset_id != 0 {
                    bail!(
                        "Real proofs have asset_id={}, but dummy proofs use asset_id=0. \
                         All proofs must have the same asset_id for aggregation.",
                        real_asset_id
                    );
                }
            }

            // Clone the dummy proof template as many times as needed for padding.
            // Each clone gets a unique nullifier during aggregation to avoid
            // duplicate nullifier errors on-chain.
            for _ in 0..num_dummies_needed {
                proofs.push(self.dummy_proof_template.clone());
            }
        }

        // Shuffle proofs to hide dummy positions while keeping a real proof in slot 0.
        // This makes dummy proofs indistinguishable from duplicate exit accounts in the output.
        let wrapper = WormholeAggregationWrapper::new(proofs.len());
        shuffle_proofs_preserving_first_real(&mut proofs, &wrapper);

        let root_proof = aggregate_proofs(
            proofs,
            &self.leaf_circuit_data.common,
            &self.leaf_circuit_data.verifier_only,
        )?;

        Ok(root_proof)
    }
}

/// Turn flat leaf public inputs into `AggregatedPublicCircuitInputs`.
fn aggregate_public_inputs(
    leaves: Vec<PublicCircuitInputs>,
) -> anyhow::Result<AggregatedPublicCircuitInputs> {
    let first_leaf = leaves
        .first()
        .ok_or_else(|| anyhow::anyhow!("no leaves provided"))?;
    let asset_id = first_leaf.asset_id;
    let volume_fee_bps = first_leaf.volume_fee_bps;

    // Verify all leaves have the same volume_fee_bps
    for leaf in &leaves {
        if leaf.volume_fee_bps != volume_fee_bps {
            anyhow::bail!(
                "all leaves must have the same volume_fee_bps, expected {} but got {}",
                volume_fee_bps,
                leaf.volume_fee_bps
            );
        }
    }

    let mut by_account: BTreeMap<BytesDigest, PublicInputsByAccount> = BTreeMap::new();
    let nullifiers: Vec<BytesDigest> = leaves.iter().map(|leaf| leaf.nullifier).collect();

    let mut block_data = BlockData::default();

    for leaf in leaves {
        // If the block number is greater than the current, update block_data.
        if leaf.block_number > block_data.block_number {
            block_data.block_number = leaf.block_number;
            block_data.block_hash = leaf.block_hash;
        }

        // Process first output (exit_account_1, output_amount_1)
        let acct_entry_1 =
            by_account
                .entry(leaf.exit_account_1)
                .or_insert_with(|| PublicInputsByAccount {
                    summed_output_amount: 0u32,
                    exit_account: leaf.exit_account_1,
                });

        acct_entry_1.summed_output_amount = acct_entry_1
            .summed_output_amount
            .checked_add(leaf.output_amount_1)
            .ok_or_else(|| {
                anyhow::anyhow!(
                    "overflow while summing output amounts for exit account {:?}",
                    acct_entry_1.exit_account
                )
            })?;

        // Process second output (exit_account_2, output_amount_2)
        // Only if the exit account is non-zero (skip unused second outputs)
        if leaf.exit_account_2 != BytesDigest::default() || leaf.output_amount_2 > 0 {
            let acct_entry_2 =
                by_account
                    .entry(leaf.exit_account_2)
                    .or_insert_with(|| PublicInputsByAccount {
                        summed_output_amount: 0u32,
                        exit_account: leaf.exit_account_2,
                    });

            acct_entry_2.summed_output_amount = acct_entry_2
                .summed_output_amount
                .checked_add(leaf.output_amount_2)
                .ok_or_else(|| {
                    anyhow::anyhow!(
                        "overflow while summing output amounts for exit account {:?}",
                        acct_entry_2.exit_account
                    )
                })?;
        }
    }

    let mut accounts: Vec<PublicInputsByAccount> = by_account.into_values().collect();

    // Sort accounts by the same comparator on the exit account.
    accounts.sort_by_key(|a| digest_key_le_u64x4(&a.exit_account));

    Ok(AggregatedPublicCircuitInputs {
        asset_id,
        volume_fee_bps,
        block_data,
        account_data: accounts,
        nullifiers,
    })
}

#[inline]
fn digest_key_le_u64x4(d: &BytesDigest) -> [u64; 4] {
    let bytes: &[u8; 32] = d; // e.g., impl AsRef<[u8;32]> for BytesDigest
    [
        u64::from_le_bytes(bytes[0..8].try_into().unwrap()),
        u64::from_le_bytes(bytes[8..16].try_into().unwrap()),
        u64::from_le_bytes(bytes[16..24].try_into().unwrap()),
        u64::from_le_bytes(bytes[24..32].try_into().unwrap()),
    ]
}
