#![cfg(test)]

use plonky2::plonk::proof::ProofWithPublicInputs;
use wormhole_aggregator::aggregator::WormholeProofAggregator;
use wormhole_circuit::inputs::{CircuitInputs, PublicCircuitInputs};
use wormhole_prover::WormholeProver;
use zk_circuits_common::circuit::{C, D, F};

use crate::aggregator::circuit_config;
use test_helpers::TestInputs;

#[test]
fn push_proof_to_buffer() {
    // Create a proof.
    let prover = WormholeProver::new(circuit_config());
    let inputs = CircuitInputs::test_inputs_0();
    let proof = prover.commit(&inputs).unwrap().prove().unwrap();

    let mut aggregator = WormholeProofAggregator::from_circuit_config(circuit_config());
    aggregator.push_proof(proof).unwrap();

    let proofs_buffer = aggregator.proofs_buffer.unwrap();
    assert_eq!(proofs_buffer.len(), 1);
}

#[test]
fn push_proof_to_full_buffer() {
    // Create a proof.
    let prover = WormholeProver::new(circuit_config());
    let inputs = CircuitInputs::test_inputs_0();
    let proof = prover.commit(&inputs).unwrap().prove().unwrap();

    let mut aggregator = WormholeProofAggregator::from_circuit_config(circuit_config());

    // Fill up the proof buffer.
    for _ in 0..aggregator.config.num_leaf_proofs {
        aggregator.push_proof(proof.clone()).unwrap();
    }

    let result = aggregator.push_proof(proof.clone());
    assert!(result.is_err());

    let proofs_buffer = aggregator.proofs_buffer.unwrap();
    assert_eq!(proofs_buffer.len(), aggregator.config.num_leaf_proofs);
}

#[test]
fn aggregate_single_proof() {
    // Create a proof.
    let prover = WormholeProver::new(circuit_config());
    let inputs = CircuitInputs::test_inputs_0();
    let proof = prover.commit(&inputs).unwrap().prove().unwrap();

    let mut aggregator = WormholeProofAggregator::from_circuit_config(circuit_config());
    aggregator.push_proof(proof).unwrap();

    aggregator.aggregate().unwrap();
}

#[test]
fn aggregate_proofs_into_tree() {
    // Create proofs - all must be from the SAME BLOCK for fixed-structure aggregation
    // Use test_inputs_0 for all proofs (same block)
    let inputs = CircuitInputs::test_inputs_0();
    let mut proofs = Vec::new();

    for idx in 0..2 {
        let prover = WormholeProver::new(circuit_config());
        let proof = prover.commit(&inputs).unwrap().prove().unwrap();
        let public_inputs = PublicCircuitInputs::try_from(&proof).unwrap();
        println!(
            "public inputs of original proof number {:?} = {:?}",
            idx, public_inputs
        );
        proofs.push(proof);
    }

    let mut aggregator = WormholeProofAggregator::from_circuit_config(circuit_config());

    // Fill up the proof buffer (all proofs from same block)
    for i in 0..aggregator.config.num_leaf_proofs {
        aggregator.push_proof(proofs[i % 2].clone()).unwrap();
    }

    let aggregated_proof = aggregator.aggregate().unwrap(); // AggregatedProof<F, C, D>

    // Verify the aggregated proof
    aggregated_proof
        .circuit_data
        .verify(aggregated_proof.proof)
        .unwrap();
}

#[test]
fn aggregate_half_full_proof_array_into_tree() {
    // Create a proof.
    let prover = WormholeProver::new(circuit_config());
    let inputs = CircuitInputs::test_inputs_0();
    let proof = prover.commit(&inputs).unwrap().prove().unwrap();

    let mut aggregator = WormholeProofAggregator::from_circuit_config(circuit_config());

    // Fill up the proof buffer.
    for _ in 0..aggregator.config.num_leaf_proofs {
        aggregator.push_proof(proof.clone()).unwrap();
    }

    let aggregated_proof = aggregator.aggregate().unwrap();
    aggregated_proof
        .circuit_data
        .verify(aggregated_proof.proof)
        .unwrap();
}

/// This test simulates the CLI flow where:
/// 1. Proofs are generated by separate WormholeProver instances (simulating separate CLI calls)
/// 2. Proofs are serialized to bytes (simulating writing to files)
/// 3. A new WormholeProofAggregator is created (simulating the aggregate command)
/// 4. Proofs are deserialized using the aggregator's common_data
/// 5. Aggregation is attempted
///
/// This tests whether different WormholeProver instances produce compatible proofs.
#[test]
fn aggregate_proofs_from_separate_prover_instances_serialized() {
    println!("=== Testing CLI-like flow with separate prover instances ===");

    // Step 1: Generate proof 1 with prover instance A
    println!("Creating prover A and generating proof 1...");
    let prover_a = WormholeProver::new(circuit_config());
    let inputs_1 = CircuitInputs::test_inputs_0();
    let proof_1 = prover_a.commit(&inputs_1).unwrap().prove().unwrap();
    let proof_1_bytes = proof_1.to_bytes();
    println!("Proof 1 generated, {} bytes", proof_1_bytes.len());

    // Step 2: Generate proof 2 with a DIFFERENT prover instance B
    // NOTE: Must use same block as proof 1 for fixed-structure aggregation
    println!("Creating prover B and generating proof 2...");
    let prover_b = WormholeProver::new(circuit_config());
    let inputs_2 = CircuitInputs::test_inputs_0(); // Same block as inputs_1
    let proof_2 = prover_b.commit(&inputs_2).unwrap().prove().unwrap();
    let proof_2_bytes = proof_2.to_bytes();
    println!("Proof 2 generated, {} bytes", proof_2_bytes.len());

    // Step 3: Create aggregator (this creates yet another prover instance internally for dummy proofs)
    println!("Creating aggregator (creates internal prover for dummy proofs)...");
    let mut aggregator = WormholeProofAggregator::from_circuit_config(circuit_config());
    let common_data = aggregator.leaf_circuit_data.common.clone();

    // Step 4: Deserialize proofs using aggregator's common_data (like CLI does)
    println!("Deserializing proofs using aggregator's common_data...");
    let proof_1_deserialized: ProofWithPublicInputs<F, C, D> =
        ProofWithPublicInputs::from_bytes(proof_1_bytes, &common_data)
            .expect("Failed to deserialize proof 1");
    let proof_2_deserialized: ProofWithPublicInputs<F, C, D> =
        ProofWithPublicInputs::from_bytes(proof_2_bytes, &common_data)
            .expect("Failed to deserialize proof 2");
    println!("Proofs deserialized successfully");

    // Step 5: Push proofs to aggregator
    println!("Pushing proofs to aggregator...");
    aggregator.push_proof(proof_1_deserialized).unwrap();
    aggregator.push_proof(proof_2_deserialized).unwrap();

    // Step 6: Attempt aggregation
    println!("Running aggregation...");
    let aggregated_proof = aggregator.aggregate().expect("Aggregation failed");

    // Verify the aggregated proof
    println!("Verifying aggregated proof...");
    aggregated_proof
        .circuit_data
        .verify(aggregated_proof.proof)
        .expect("Aggregated proof verification failed");

    println!("=== Test passed! ===");
}

/// This test reproduces the bug where the aggregator's dummy proof comes from
/// a different circuit build than its verifier_data.
///
/// The old buggy code in `from_circuit_config` did:
/// 1. Create prover A, generate dummy proof from A
/// 2. Create circuit B (separate build), get verifier_data from B
/// 3. Use verifier_data from B with dummy proof from A -> MISMATCH!
#[test]
#[ignore = "test setup needs updating - only provides 1 dummy proof but aggregator expects 8"]
fn reproduce_wire_set_twice_bug() {
    println!("=== Reproducing the wire-set-twice bug ===");

    // Simulate the OLD buggy from_circuit_config behavior:
    // 1. Create prover instance A and generate dummy proof
    println!("Creating prover A for dummy proof...");
    let prover_a = WormholeProver::new(circuit_config());
    let dummy_inputs = CircuitInputs::test_inputs_0(); // Use as dummy
    let dummy_proof = prover_a.commit(&dummy_inputs).unwrap().prove().unwrap();

    // 2. Create a SEPARATE circuit instance B for verifier_data (THIS IS THE BUG!)
    println!("Creating separate circuit B for verifier_data (BUG!)...");
    use wormhole_circuit::circuit::circuit_logic::WormholeCircuit;
    let circuit_b = WormholeCircuit::new(circuit_config());
    let verifier_data = circuit_b.build_verifier();

    // 3. Create aggregator with mismatched verifier_data and dummy_proof
    println!("Creating aggregator with mismatched circuit builds...");
    let mut aggregator = WormholeProofAggregator::new(verifier_data, vec![dummy_proof]);

    // 4. Generate a real proof with yet another prover instance
    println!("Creating prover C for real proof...");
    let prover_c = WormholeProver::new(circuit_config());
    let real_inputs = CircuitInputs::test_inputs_1();
    let real_proof = prover_c.commit(&real_inputs).unwrap().prove().unwrap();

    // 5. Push the real proof
    aggregator.push_proof(real_proof).unwrap();

    // 6. Attempt aggregation - this should fail with "wire set twice"
    println!("Running aggregation (expecting failure)...");
    let result = aggregator.aggregate();

    // This SHOULD fail with the bug, but let's see what happens
    match result {
        Ok(_) => {
            println!("WARNING: Aggregation succeeded - bug may not be reproduced");
            // If it succeeds, the test still passes but we note it
        }
        Err(e) => {
            let error_msg = e.to_string();
            println!("Aggregation failed as expected: {}", error_msg);
            assert!(
                error_msg.contains("set twice") || error_msg.contains("wire"),
                "Expected 'wire set twice' error, got: {}",
                error_msg
            );
            println!("=== Bug successfully reproduced! ===");
        }
    }
}

/// Test that verifies the aggregated proof can be verified using the pre-built
/// verifier binaries (simulating on-chain verification).
///
/// This test uses pre-built circuit files throughout to match the production flow:
/// 1. Prover loads from pre-built prover.bin + common.bin
/// 2. Aggregator loads from the same pre-built files
/// 3. Verifier loads from pre-built aggregated_verifier.bin + aggregated_common.bin
#[test]
#[ignore = "requires regenerating circuit binaries after 2-output layout change"]
fn verify_aggregated_proof_with_prebuilt_verifier() {
    use std::path::Path;
    use wormhole_verifier::WormholeVerifier;
    // Use the verifier's types for deserialization (these come from qp_plonky2_verifier)
    use wormhole_verifier::ProofWithPublicInputs as VerifierProof;

    println!("=== Testing aggregated proof verification with pre-built verifier ===");

    // Step 1: Load prover from pre-built files (like CLI does in production)
    // The bins are at repo root, tests run from wormhole/tests
    println!("Loading prover from pre-built files...");
    let prover = WormholeProver::new_from_files(
        Path::new("../../generated-bins/prover.bin"),
        Path::new("../../generated-bins/common.bin"),
    )
    .expect("Failed to load prover from pre-built files");

    // Step 2: Generate proofs using the pre-built prover
    // NOTE: All proofs must be from the SAME block for the fixed-structure aggregation circuit
    println!("Generating proofs...");
    let inputs_1 = CircuitInputs::test_inputs_0();
    let proof_1 = prover.commit(&inputs_1).unwrap().prove().unwrap();

    // Reload prover for second proof (prover consumes itself on commit)
    let prover = WormholeProver::new_from_files(
        Path::new("../../generated-bins/prover.bin"),
        Path::new("../../generated-bins/common.bin"),
    )
    .expect("Failed to load prover from pre-built files");
    // Use test_inputs_0 again but with different nullifier/exit to simulate same-block proofs
    // For this test, we just use the same inputs twice - the aggregator will pad with dummies
    let inputs_2 = CircuitInputs::test_inputs_0();
    let proof_2 = prover.commit(&inputs_2).unwrap().prove().unwrap();

    // Step 3: Create aggregator from pre-built files (matches circuit-builder)
    // The bins are at repo root, tests run from wormhole/tests
    println!("Creating aggregator from pre-built files...");
    let mut aggregator = WormholeProofAggregator::from_prebuilt_with_paths(
        Path::new("../../generated-bins/prover.bin"),
        Path::new("../../generated-bins/common.bin"),
        Path::new("../../generated-bins/verifier.bin"),
    )
    .expect("Failed to create aggregator from pre-built files");

    aggregator.push_proof(proof_1).unwrap();
    aggregator.push_proof(proof_2).unwrap();

    let aggregated = aggregator.aggregate().expect("Aggregation failed");
    println!("Aggregation succeeded!");

    // Debug: Print the circuit digest from the aggregated proof
    println!(
        "Aggregated proof's circuit_digest: {:?}",
        aggregated.circuit_data.verifier_only.circuit_digest
    );

    // Step 4: Serialize the aggregated proof (like CLI does)
    let aggregated_proof_bytes = aggregated.proof.to_bytes();
    let aggregated_proof_hex = hex::encode(&aggregated_proof_bytes);
    println!(
        "Aggregated proof serialized: {} bytes, {} hex chars",
        aggregated_proof_bytes.len(),
        aggregated_proof_hex.len()
    );

    // Step 5: Load the pre-built aggregated verifier (like chain does)
    println!("Loading pre-built aggregated verifier...");
    let verifier = WormholeVerifier::new_from_files(
        Path::new("../../generated-bins/aggregated_verifier.bin"),
        Path::new("../../generated-bins/aggregated_common.bin"),
    )
    .expect("Failed to load aggregated verifier from pre-built files");

    // Debug: Print the circuit digest from the pre-built verifier
    println!(
        "Pre-built verifier's circuit_digest: {:?}",
        verifier.circuit_data.verifier_only.circuit_digest
    );

    // Step 6: Deserialize proof using verifier's common_data (like chain does)
    // We use the verifier's ProofWithPublicInputs type from qp_plonky2_verifier
    println!("Deserializing aggregated proof using verifier's common_data...");
    let decoded_bytes = hex::decode(&aggregated_proof_hex).expect("Failed to decode hex");
    let deserialized_proof: VerifierProof<
        wormhole_verifier::F,
        wormhole_verifier::C,
        { wormhole_verifier::D },
    > = VerifierProof::from_bytes(decoded_bytes, &verifier.circuit_data.common)
        .expect("Failed to deserialize aggregated proof");

    // Step 7: Verify using the pre-built verifier (like chain does)
    println!("Verifying aggregated proof with pre-built verifier...");
    verifier
        .verify(deserialized_proof)
        .expect("Aggregated proof verification failed!");

    println!("=== Aggregated proof verified successfully with pre-built verifier! ===");
}

/// Same as above but with hex encoding/decoding to exactly match CLI flow
#[test]
fn aggregate_proofs_from_separate_prover_instances_hex_serialized() {
    println!("=== Testing CLI-like flow with hex encoding ===");

    // Step 1: Generate proof 1 with prover instance A
    println!("Creating prover A and generating proof 1...");
    let prover_a = WormholeProver::new(circuit_config());
    let inputs_1 = CircuitInputs::test_inputs_0();
    let proof_1 = prover_a.commit(&inputs_1).unwrap().prove().unwrap();
    let proof_1_hex = hex::encode(proof_1.to_bytes());
    println!("Proof 1 generated, {} hex chars", proof_1_hex.len());

    // Step 2: Generate proof 2 with a DIFFERENT prover instance B
    // NOTE: Must use same block as proof 1 for fixed-structure aggregation
    println!("Creating prover B and generating proof 2...");
    let prover_b = WormholeProver::new(circuit_config());
    let inputs_2 = CircuitInputs::test_inputs_0(); // Same block as inputs_1
    let proof_2 = prover_b.commit(&inputs_2).unwrap().prove().unwrap();
    let proof_2_hex = hex::encode(proof_2.to_bytes());
    println!("Proof 2 generated, {} hex chars", proof_2_hex.len());

    // Step 3: Create aggregator (this creates yet another prover instance internally for dummy proofs)
    println!("Creating aggregator (creates internal prover for dummy proofs)...");
    let mut aggregator = WormholeProofAggregator::from_circuit_config(circuit_config());
    let common_data = aggregator.leaf_circuit_data.common.clone();

    // Step 4: Decode hex and deserialize proofs using aggregator's common_data (like CLI does)
    println!("Decoding hex and deserializing proofs...");
    let proof_1_bytes = hex::decode(&proof_1_hex).expect("Failed to decode proof 1 hex");
    let proof_2_bytes = hex::decode(&proof_2_hex).expect("Failed to decode proof 2 hex");

    let proof_1_deserialized: ProofWithPublicInputs<F, C, D> =
        ProofWithPublicInputs::from_bytes(proof_1_bytes, &common_data)
            .expect("Failed to deserialize proof 1");
    let proof_2_deserialized: ProofWithPublicInputs<F, C, D> =
        ProofWithPublicInputs::from_bytes(proof_2_bytes, &common_data)
            .expect("Failed to deserialize proof 2");
    println!("Proofs deserialized successfully");

    // Step 5: Push proofs to aggregator
    println!("Pushing proofs to aggregator...");
    aggregator.push_proof(proof_1_deserialized).unwrap();
    aggregator.push_proof(proof_2_deserialized).unwrap();

    // Step 6: Attempt aggregation
    println!("Running aggregation...");
    let aggregated_proof = aggregator.aggregate().expect("Aggregation failed");

    // Verify the aggregated proof
    println!("Verifying aggregated proof...");
    aggregated_proof
        .circuit_data
        .verify(aggregated_proof.proof)
        .expect("Aggregated proof verification failed");

    println!("=== Test passed! ===");
}

/// Test that verifies a CLI-generated aggregated proof hex file using the pre-built verifier.
/// This exactly simulates what the chain does during on-chain verification.
///
/// To use: Set the PROOF_HEX_FILE env var to the path of the hex file:
///   PROOF_HEX_FILE=/path/to/proof.hex cargo test --package tests --release verify_external_proof_hex -- --ignored --nocapture
#[test]
#[ignore] // Run manually with PROOF_HEX_FILE env var
fn verify_external_proof_hex() {
    use std::path::Path;
    use wormhole_verifier::ProofWithPublicInputs as VerifierProof;
    use wormhole_verifier::WormholeVerifier;

    let proof_file = std::env::var("PROOF_HEX_FILE")
        .expect("Set PROOF_HEX_FILE env var to the path of the aggregated proof hex file");

    println!("=== Verifying external proof file: {} ===", proof_file);

    // Step 1: Load the proof hex
    let proof_hex = std::fs::read_to_string(&proof_file).expect("Failed to read proof file");
    let proof_bytes = hex::decode(proof_hex.trim()).expect("Failed to decode hex");
    println!("Proof size: {} bytes", proof_bytes.len());

    // Step 2: Load the pre-built aggregated verifier (same as chain)
    println!("Loading pre-built aggregated verifier...");
    let verifier = WormholeVerifier::new_from_files(
        Path::new("../../generated-bins/aggregated_verifier.bin"),
        Path::new("../../generated-bins/aggregated_common.bin"),
    )
    .expect("Failed to load aggregated verifier");

    println!(
        "Verifier circuit_digest: {:?}",
        verifier.circuit_data.verifier_only.circuit_digest
    );

    // Step 3: Deserialize proof using verifier's common_data (same as chain)
    println!("Deserializing proof...");
    let proof: VerifierProof<wormhole_verifier::F, wormhole_verifier::C, { wormhole_verifier::D }> =
        VerifierProof::from_bytes(proof_bytes, &verifier.circuit_data.common)
            .expect("Failed to deserialize proof");

    println!("Proof public inputs count: {}", proof.public_inputs.len());
    println!(
        "Verifier expects {} public inputs",
        verifier.circuit_data.common.num_public_inputs
    );

    // Parse and check nullifiers for duplicates
    // Convert GoldilocksField to u64 for parsing with the inputs crate
    // Use the same trait that qp_plonky2_verifier uses
    let pis_u64: Vec<u64> = proof
        .public_inputs
        .iter()
        .map(|f| f.0) // GoldilocksField inner u64 value
        .collect();
    let inputs = wormhole_verifier::AggregatedPublicCircuitInputs::try_from_u64_slice(&pis_u64)
        .expect("Failed to parse aggregated inputs");

    println!("Number of nullifiers: {}", inputs.nullifiers.len());
    let mut seen = std::collections::HashSet::new();
    for (i, n) in inputs.nullifiers.iter().enumerate() {
        let bytes: &[u8] = n.as_ref();
        println!("Nullifier {}: 0x{}", i, hex::encode(bytes));
        if !seen.insert(bytes.to_vec()) {
            println!("*** DUPLICATE NULLIFIER at index {}! ***", i);
        }
    }

    // Step 4: Verify (same as chain)
    println!("Verifying proof...");
    verifier.verify(proof).expect("Proof verification FAILED!");

    println!("=== Proof verified successfully! ===");
}
