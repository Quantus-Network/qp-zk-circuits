//! Verifier logic for the Wormhole circuit.
//!
//! This module provides the [`WormholeVerifier`] type, which allows for the verification of
//! zero-knowledge proofs generated by the Wormhole circuit.
//!
//! The typical usage flow involves:
//! 1. Initializing the verifier from pre-built circuit data via [`WormholeVerifier::new_from_bytes()`].
//! 2. Deserializing a [`ProofWithPublicInputs`].
//! 3. Verifying the proof using [`WormholeVerifier::verify`].
//!
//! # Example
//!
//! ```ignore
//! use qp_wormhole_verifier::{WormholeVerifier, ProofWithPublicInputs, C, D, F};
//!
//! // Load verifier from pre-serialized bytes
//! let verifier = WormholeVerifier::new_from_bytes(verifier_bytes, common_bytes)?;
//!
//! // Deserialize the proof
//! let proof = ProofWithPublicInputs::<F, C, D>::from_bytes(proof_bytes, &verifier.circuit_data.common)?;
//!
//! // Verify
//! verifier.verify(proof)?;
//! ```
#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(not(feature = "std"))]
extern crate alloc;

#[cfg(not(feature = "std"))]
use alloc::vec::Vec;
#[cfg(feature = "std")]
use std::vec::Vec;

use anyhow::anyhow;
#[cfg(feature = "std")]
use std::path::Path;

// Re-export types from qp-plonky2-verifier
pub use qp_plonky2_verifier::{
    CommonCircuitData, ProofWithPublicInputs, VerifierCircuitData, VerifierOnlyCircuitData, C, D, F,
};

use qp_plonky2_verifier::field::types::PrimeField64;
use qp_plonky2_verifier::util::serialization::DefaultGateSerializer;

// Re-export input types from qp-wormhole-inputs
pub use qp_wormhole_inputs::{
    AggregatedPublicCircuitInputs, BlockData, BytesDigest, PublicCircuitInputs,
    PublicInputsByAccount,
};

/// Parse public inputs from a proof.
pub fn parse_public_inputs(
    proof: &ProofWithPublicInputs<F, C, D>,
) -> anyhow::Result<PublicCircuitInputs> {
    let u64s: Vec<u64> = proof
        .public_inputs
        .iter()
        .map(|f| f.to_canonical_u64())
        .collect();
    PublicCircuitInputs::try_from_u64_slice(&u64s)
}

/// Parse aggregated public inputs from a proof.
pub fn parse_aggregated_public_inputs(
    proof: &ProofWithPublicInputs<F, C, D>,
) -> anyhow::Result<AggregatedPublicCircuitInputs> {
    let u64s: Vec<u64> = proof
        .public_inputs
        .iter()
        .map(|f| f.to_canonical_u64())
        .collect();
    AggregatedPublicCircuitInputs::try_from_u64_slice(&u64s)
}

/// Verifier for Wormhole circuit proofs.
///
/// This struct wraps the circuit verification data and provides methods to verify proofs.
#[derive(Debug)]
pub struct WormholeVerifier {
    pub circuit_data: VerifierCircuitData<F, C, D>,
}

impl WormholeVerifier {
    /// Creates a new [`WormholeVerifier`] from verifier and common data bytes.
    ///
    /// This is the primary constructor for no_std environments like on-chain verification.
    pub fn new_from_bytes(
        verifier_bytes: &[u8],
        common_bytes: &[u8],
    ) -> Result<Self, &'static str> {
        let verifier_only = VerifierOnlyCircuitData::from_bytes(verifier_bytes.to_vec())
            .map_err(|_| "Failed to deserialize verifier data from bytes")?;

        let common = CommonCircuitData::from_bytes(common_bytes.to_vec(), &DefaultGateSerializer)
            .map_err(|_| "Failed to deserialize common circuit data from bytes")?;

        let circuit_data = VerifierCircuitData {
            verifier_only,
            common,
        };

        Ok(Self { circuit_data })
    }

    /// Creates a new [`WormholeVerifier`] from a verifier and common data files.
    ///
    /// This is a convenience method for std environments.
    #[cfg(feature = "std")]
    pub fn new_from_files(
        verifier_data_path: &Path,
        common_data_path: &Path,
    ) -> anyhow::Result<Self> {
        let verifier_bytes = std::fs::read(verifier_data_path)?;

        let verifier_only = VerifierOnlyCircuitData::from_bytes(verifier_bytes).map_err(|e| {
            anyhow!(
                "Failed to deserialize verifier data from {:?}: {}",
                verifier_data_path,
                e
            )
        })?;

        let common_bytes = std::fs::read(common_data_path)?;
        let common =
            CommonCircuitData::from_bytes(common_bytes, &DefaultGateSerializer).map_err(|e| {
                anyhow!(
                    "Failed to deserialize common circuit data from {:?}: {}",
                    common_data_path,
                    e
                )
            })?;

        let circuit_data = VerifierCircuitData {
            verifier_only,
            common,
        };

        Ok(Self { circuit_data })
    }

    /// Verify a [`ProofWithPublicInputs`].
    ///
    /// # Errors
    ///
    /// Returns an error if the proof is not valid.
    pub fn verify(&self, proof: ProofWithPublicInputs<F, C, D>) -> anyhow::Result<()> {
        self.circuit_data
            .verify(proof)
            .map_err(|e| anyhow!("proof verification failed: {}", e))
    }
}
